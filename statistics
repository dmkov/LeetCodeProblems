Solved:

May 2019:
26 - 53, 26, 122
27 - 443, 204
28 - 350, 11, 345
29 - 374
30 - 100
31 - 572

June 2019:
3 - 844
4 - 496, 232, 35
5 - 14
11 - 530
12 - 437, 530
15 - 976
16 - 441
17 - 171, 883
18 - 263, 235, 155

July 2019
1 - 112
2 - 623
3 - 268
4 - 367, 645
6 - 455
7 - 160, 200
23 - 438
30 - 198
31 - 226

August 2019
1 - 283
2 - 448, 238
3 - 538
4 - 234, 169
5 - 543, 617
12 - 104
13 - 136, 581
17 - 21, 70, 101, 118
18 - 217
19 - 326
25 - 234, 287
31 - 221, 230, 494

November 2019
4 - 66
5 - 119
7 - 643
25 - 110
26 - 96
27 - 102
28 - 222
30 - 200

December 2019
1 - 430
8 - 10
10 - 103
11 - 94
15 - 116
24 - 341
25 - 191, 371
26 - 190
27 - 240
29 - 253

January 2020
5 - 347
6 - 401, 2
7 - 3, 973
8 - 348, 1099
10 - 957
11 - 202, 937, 49
12 - 31, 56
13 - 34, 139
14 - 138, 380, 120
15 - 426, 228
16 - 636, 236
17 - 318, 78, 389, 152
19 - 767
20 - 62, 5
21 - 121, 256, 138
22 - 357, 71, 146
23 - 994, 349, 260
24 - 959
25 - 1042, 997, 1161, 841
27 - 20, 503
28 - 647, 415, 1130
29 - 819, 64
30 - 322, 199, 901, 560
31 - 1007, 289

February 2020
2 - 1155
3 - 399, 969
4 - 739, 856, 398

Done with help:
204 - did not pass timeout (non efficient solution with hashmap)
11 - did not find the best solution (n^2 instead of n)
496 - did not think about hashmap initially to speed up the iteration
232 - did not consider option to move items only when the second stack is empty to amortize pop()/peak() methods
530 - did not consider better option with O(n) complexity. Implemented nlog(n) instead.
437 - did not consider option with hashmap and O(n) complexity. Implemented n^2 instead
976 - missed idea of that the sum of two other lengths should be greater than the largest length in the triangle
441 - did not know formula for arithmetic progression
155 - did not consider option to create class to keep both value and minimum numbers
438 - sliding window approach. should be reviewed with extra attention to counters and hash map conditions
198 - almost got solution but did not think about dynamic programming approach
234 - did not consider possible solution with slow and fast pointers. remind part to reverse lists.
136 - did not think about possible XOR operation
581 - did not consider option to clone and sort array. for left/right bounds did not think about max/min elements
70 - did not find the pattern last steps plus one before the last
101 - did not consider idea with stack. for recursive solution there is much simpler approach than StringBuilder
326 - did not consider logarithmic solution. solved with the loop
287 - did not consider the second part where entrance to the loop should be found
96 - issues with combinatorics and BST definition to select the root node
222 - did not consider option to binary search in the tree
889 - did not consider option to search for the root node in post-ordered tree.
103 - did not consider solution with two stacks
94 - did not consider solution with the stack
341 - thought about empty list as a possible null in the result.
259 - in-built sorting for collections
347 - did not consider simpler PriorityQueue solution
401 - did not consider that permutation can be done with backtracking approach
3   - did not consider that we need two pointers and check again already passed characters for the new set
957 - did not think about brute force loop as of solution and sis not improve it with memoization
139 - did not think about memoization in the loop
152 - did not consider solution with tracking min value for negative numbers
767 - could not find final solution to populate string from the array
5   - could not find the memoization pattern
357 - did not consider that previous combinations should be added to the current product
146 - did not consider idea to build own linked list instead of using LinkedList class
260 - did not consider if condition in bitwise operations to filter numbers by selected bit
959 - did not consider union find approach to link nodes
503 - too complex cases with the stack usage
1130 - could not find a solution, returned back to the task couple times
560 - did not think about approach with cumulative sum of subarray
1155 - did not get idea of dp and messed up with memoization approach

Done by myself but need attention:
122 - did mistake in calculations
374 - while condition should be inclusive - while (min <= max) - in case of array with one element
100 - recursion check is more simple and efficient than migration to the array
35 - did not notice that with right shift result should be additionally incremented
922 - did not think about iterating only even indexes (i+2)
367 - overflow for integer (mid*mid). always consider overflows and edge cases.
160 - did not consider more efficient solution with two pointers
200 - did not consider option to use the same array to save space
226 - remember queue method in the linked list (pop, add and so on)
448 - after modification of the current list, we need to take abs() value to avoid negatives and index out of bounds
538 - initially did not think about simple right-order traversal
169 - check Boyer-Moore Voting Algorithm for more efficient space usage
543 - diameter for tree is sum of children depths for every node
21 - did not consider that should return first node of the result
230 - more elegant way of in-order traverse
430 - did not consider idea to reorder list with the stack
10 - did not consider that '*' quantifier can be matched 0 string. integer array for memo.
240 - did not consider better idea with search space reduction algorithm
973 - divide and conquer (partitioning) is more efficient than sorting
31  - reverse items can sort elements in descending order with O(n) instead of O(nlog(n))
56  - if crossing is found, check the max of both ends in case if one interval is inside the other.
636 - the main issue was due to the interval time calculation and messing indexes
236 - did not think about more efficient option without stack
318 - did not think about simple iteration inside the array, did not use array to store lengths
78  - did not consider option with bitwise mask
256 - modified dp before ending of the iteration and messed up remaining calculations
994 - should think better about edge cases
322 - the upper bound in 'bottom to top' approach may lead to overflow after adding a new coin
199 - edge case when the left node has deeper subtree than the right one
1007 - did not consider all test cases
856 - did not consider simpler solution with bitwise shift


What was learned:
102 - 1) There is no Queue class, only interface. Use LinkedList for implementation
      2) add() / remove() methods for LinkedList. The last one returns element
      3) Level traverse can be done with one queue and without recursion. Use queue.size() to split the current level
         from new elements.
    - Write down all length / length() / size() methods in main structures
    - check definitions of possible traverses (postorder traverse)
222 - binary search (mid with plus or not, less or equal and so on)
    - Math.pow - returns double and should be casted to int
    - name of traverses
200 - char is formatted by single quote
10  - substring() method with one argument for the string.
    - we can use 2d integer array for memo if we have pair of values
889 - there is Arrays.copyOfRange() method that can be used to make copies in recursive calls
103 - stack methods pop() and push()
94  - iterative traverse of the tree can be done with a stack
112 - object does not have default value - assign it to null manually (initialization error)
341 - list.iterator() can be used with next() and hasNext() methods
    - properties of the class are initialized to null (with no initialization error at startup)
191 - integer number consist of 32 bits
    - all bitwise operation '(n & 1) == 1' should be always put into brackets in logical condition
190 - after masking the bit, compare it with '0' and not '> 0' because of numbers with leading '1' are negative.
240 - if description says that the data is sorted the task almost always can be solved with the binary search.
347 - in-built PriorityQueue class to get the max "k" elements. Use it for interface to have poll() and add() methods.
401 - if we need only one bit in the number, we can use integer presentation {1, 2, 4, 8 ...}.
2   - to get modulo (%) from dividing by 10 we can always perform (x % 10). If it is less than 10, it will return the current value
3   - array with ASCII codes as indexes can be used to compare characters in string. Alphabet consists of 26 letters, 'A' starts at 65, 'a' at 97
973 - to initiate two-dimensional array the first dimension length should be specified (int[][] arr = new int[X][])
    - instead of creating every subarray manually, it can be done by specifying second length (int[][] arr = new int[X][Y])
    - comparator returns int but if we have float values they should be additionally casted or own logic should be placed there
    - always check the variable types!
    - heapsort is better than quicksort if we need only first K elements (NlogK complexity)
1099 - if we need to find element in the array, the worst case is to sort it and find the value with binary search. it gives nlogn.
957 - simply and brute force iterating can be also an answer but with memoization we can do it an efficient solution
    - always start with the naive solution and try to improve it
937 - Arrays.sort can be done with the range
49  - Nested structures should not be specified in variable initialization (List<List<String>> res = new ArrayList<>());
31  - To sort elements in descending order we can reverse them to make ascending order with O(n)
56  - for the task with intervals create one test case where one interval inside another
139 - when you iterate options always think for memoization. it can improve even brute force solution
    - if we have possible combinations in the description, the task probably can be solved with the dynamic programming
120 - try to reverse order in dp tasks, it might be more simpler and shorter
    - if bounds are complex, try to add if statements (even ternary version) for edge cases
636 - always check variable types and types of function results with extra attention
236 - if you need to return multiple results from the method, think about class property to store results
318 - think about simple iteration first and then do optimization step by step
389 - difference between strings can be found using bitwise ^ for all characters in both strings
767 - if not sure about converting types (for example int to char) - use casting, (char) for example
5   - for dp tasks, try to solve it with the array for memoization or matrix with results to compute and use in the next iterations
    - try to point to all facts that you know - tell what you see and try to apply it somehow for the solution
256 - optimization migth play bad thing, try to keep code as simple as possible, even if it is not so clean
71  - string builder prepending can be done with insert(0, string) but it is better to avoid it and simply do string concating
146 - in design think about what data structure provide what time complexity, try to narrow to them in the solution
994 - always think about edge cases, especially in easy task. check all of them in debugging phase
20  - mod operation is '%' (not x mod y :))
415 - the overflow from sum is named 'carry' :)
819 - simply regexp can help in the basic actions like word splitting
322 - always check for integer overflow after adding a new amount to the input parameters
    - primitive types in the array could not be sorted using a comparator
969 - if use Map.Entry always specify type in generic Map.Entry<Integer, Integer>
    - PriorityQueue by default use Arrays.sort (so it is min heap). To use as max heap a comparator is needed
    - Integer and Double should be compared usng equals, not ==
398 - random() function returns the double result and should be cast to int additionally
