Solved:

May 2019:
26 - 53, 26, 122
27 - 443, 204
28 - 350, 11, 345
29 - 374
30 - 100
31 - 572

June 2019:
3 - 844
4 - 496, 232, 35
5 - 14
11 - 530
12 - 437, 530
15 - 976
16 - 441
17 - 171, 883
18 - 263, 235, 155

July 2019
1 - 112
2 - 623
3 - 268
4 - 367, 645
6 - 455
7 - 160, 200
23 - 438
30 - 198
31 - 226

August 2019
1 - 283
2 - 448, 238
3 - 538
4 - 234, 169
5 - 543, 617
12 - 104
13 - 136, 581
17 - 21, 70, 101, 118
18 - 217
19 - 326
25 - 234, 287
31 - 221, 230, 494

November 2019
4 - 66
5 - 119
7 - 643
25 - 110
26 - 102

Done with help:
204 - did not pass timeout (non efficient solution with hashmap)
11 - did not find the best solution (n^2 instead of n)
496 - did not think about hashmap initially to speed up the iteration
232 - did not consider option to move items only when the second stack is empty to amortize pop()/peak() methods
530 - did not consider better option with O(n) complexity. Implemented nlog(n) instead.
437 - did not consider option with hashmap and O(n) complexity. Implemented n^2 instead
976 - missed idea of that the sum of two other lengths should be greater than the largest length in the triangle
441 - did not know formula for arithmetic progression
155 - did not consider option to create class to keep both value and minimum numbers
438 - sliding window approach. should be reviewed with extra attention to counters and hash map conditions
198 - almost got solution but did not think about dynamic programming approach
234 - did not consider possible solution with slow and fast pointers. remind part to reverse lists.
136 - did not think about possible XOR operation
581 - did not consider option to clone and sort array. for left/right bounds did not think about max/min elements
70 - did not find the pattern last steps plus one before the last
101 - did not consider idea with stack. for recursive solution there is much simpler approach than StringBuilder
326 - did not consider logarithmic solution. solved with the loop
287 - did not consider the second part where entrance to the loop should be found
96 - issues with combinatorics and BST definition to select the root node

Done by myself but need attention:
122 - did mistake in calculations
374 - while condition should be inclusive - while (min <= max) - in case of array with one element
100 - recursion check is more simple and efficient than migration to the array
35 - did not notice that with right shift result should be additionally incremented
922 - did not think about iterating only even indexes (i+2)
367 - overflow for integer (mid*mid). always consider overflows and edge cases.
160 - did not consider more efficient solution with two pointers
200 - did not consider option to use the same array to save space
226 - remember queue method in the linked list (pop, add and so on)
448 - after modification of the current list, we need to take abs() value to avoid negatives and index out of bounds
538 - initially did not think about simple right-order traversal
169 - check Boyer-Moore Voting Algorithm for more efficient space usage
543 - diameter for tree is sum of children depths for every node
21 - did not consider that should return first node of the result
230 - more elegant way of in-order traverse


What was learned:
102 - 1) There is no Queeu class, only interface. Use LinkedList for implementation
      2) add() / remove() methods for LinkedList. The last one returns element
      3) Level traverse can be done with one queue and without recursion. Use queue.size() to split the current level
         from new elements.
