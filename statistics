Solved:

May 2019:
26 - 53, 26, 122
27 - 443, 204
28 - 350, 11, 345
29 - 374
30 - 100
31 - 572

June 2019:
3 - 844
4 - 496, 232, 35
5 - 14
11 - 530
12 - 437, 530
15 - 976
16 - 441
17 - 171, 883
18 - 263, 235, 155

July 2019
1 - 112
2 - 623
3 - 268
4 - 367, 645
6 - 455
7 - 160, 200
23 - 438
30 - 198
31 - 226

August 2019
1 - 283
2 - 448, 238
3 - 538
4 - 234, 169
5 - 543, 617
12 - 104
13 - 136, 581
17 - 21, 70, 101, 118
18 - 217
19 - 326
25 - 234, 287
31 - 221, 230, 494

November 2019
4 - 66
5 - 119
7 - 643
25 - 110
26 - 96
27 - 102
28 - 222
30 - 200

December 2019
1 - 430
8 - 10
10 - 103
11 - 94
15 - 116
24 - 341
25 - 191, 371
26 - 190
27 - 240
29 - 253

January 2020
5 - 347
6 - 401, 2
7 - 3, 973
8 - 348, 1099
10 - 957
11 - 202, 937, 49
12 - 31, 56
13 - 34, 139
14 - 138, 380, 120
15 - 426, 228
16 - 636, 236
17 - 318, 78, 389, 152
19 - 767
20 - 62, 5
21 - 121, 256, 138
22 - 357, 71, 146
23 - 994, 349, 260
24 - 959
25 - 1042, 997, 1161, 841
27 - 20, 503
28 - 647, 415, 1130
29 - 819, 64
30 - 322, 199, 901, 560
31 - 1007, 289

February 2020
2 - 1155
3 - 399, 969
4 - 739, 856, 398
7 - 907
8 - 22, (3 from contest)
9 - 1348, 1347
10 - 42, 382
13 - 545, 46, 39
14 - 647
16 - 33
17 - 17
18 - 609, 735, 84
19 - 394, 891
20 - 464, 474
21 - 698
24 - 787, 63, 1027
25 - stack design
26 - 1049, 539
27 - 692, union-find, tries
28 - 3-way partitioning, graph implementation
29 - 707, 212

March 2020
2 - sorting, 1105
3 - merge sort
4 - 332, 1181, 1048
5 - quick sort, pramp task, 1027
6 - 37
7 - 3 tasks from contest
9 - BST, 1043
10 - pramp, 273
11 - 22, heapsort, 1130
13 - topological sort, 54
15 - shortest paths, 18
16 - pramp, 364, 547
18 - 759, 981
19 - pramp, tree map
20 - radix sort, 98
21 - contest, 1387
22 - 855, 85
23 - 301
24 - pramp, 518
26 - substring search algorithms
27 - 10, mock
28 - mock
29 - mock
30 - KMP, mock, 1388
31 - 295, 1396

April 2020
1 - 1007, 297, 362
2 - 334, 679
3 - mock, 277
4 - 5 tasks from code jam
6 - 755, 909
7 - mock, 378
8 - 2 mocks, 1052
9 - 207, 1 mock
10 - max flow, 173, 274
11 - 505, mock
12 - 1192
13 - 97
14 - 525, 127
15 - 528, 42, 642
16 - 1 mock
17 - 678, 76, 92
19 - 33
20 - 336, 1197, 1008
21 - 91, 4
22 - 269, two easy
23 - 201, 68, 6
24 - 244, 218
25 - 55
26 - two easy, 1424
27 - 1143
28 - contest, 41
29 - 124

May
1 - salesman, 43
4 - 476, 752
6 - mock, 315
7 - 843
11 - 472
12 - 300
13 - 354
14 - 286, 1406
15 - 2 mocks
16 - mock, 428
19 - 2 mocks
20 - 2 mocks
21 - mock
22 - 410, 72
25 - 340
30 - 329, 359

Done with help:
204 - did not pass timeout (non efficient solution with hashmap)
11 - did not find the best solution (n^2 instead of n)
496 - did not think about hashmap initially to speed up the iteration
232 - did not consider option to move items only when the second stack is empty to amortize pop()/peak() methods
530 - did not consider better option with O(n) complexity. Implemented nlog(n) instead.
437 - did not consider option with hashmap and O(n) complexity. Implemented n^2 instead
976 - missed idea of that the sum of two other lengths should be greater than the largest length in the triangle
441 - did not know formula for arithmetic progression
155 - did not consider option to create class to keep both value and minimum numbers
438 - sliding window approach. should be reviewed with extra attention to counters and hash map conditions
198 - almost got solution but did not think about dynamic programming approach
234 - did not consider possible solution with slow and fast pointers. remind part to reverse lists.
136 - did not think about possible XOR operation
581 - did not consider option to clone and sort array. for left/right bounds did not think about max/min elements
70 - did not find the pattern last steps plus one before the last
101 - did not consider idea with stack. for recursive solution there is much simpler approach than StringBuilder
326 - did not consider logarithmic solution. solved with the loop
287 - did not consider the second part where entrance to the loop should be found
96 - issues with combinatorics and BST definition to select the root node
222 - did not consider option to binary search in the tree
889 - did not consider option to search for the root node in post-ordered tree.
103 - did not consider solution with two stacks
94 - did not consider solution with the stack
341 - thought about empty list as a possible null in the result.
259 - in-built sorting for collections
347 - did not consider simpler PriorityQueue solution
401 - did not consider that permutation can be done with backtracking approach
3   - did not consider that we need two pointers and check again already passed characters for the new set
957 - did not think about brute force loop as of solution and sis not improve it with memoization
139 - did not think about memoization in the loop
152 - did not consider solution with tracking min value for negative numbers
767 - could not find final solution to populate string from the array
5   - could not find the memoization pattern
357 - did not consider that previous combinations should be added to the current product
146 - did not consider idea to build own linked list instead of using LinkedList class
260 - did not consider if condition in bitwise operations to filter numbers by selected bit
959 - did not consider union find approach to link nodes
503 - too complex cases with the stack usage
1130 - could not find a solution, returned back to the task couple times
560 - did not think about approach with cumulative sum of subarray
1155 - did not get idea of dp and messed up with memoization approach
907 - did not consider idea with two stacks in once
22  - did not consider simple idea with counting brackets. in dp version did not consider concat "(())(())" test case
42  - did not figured out stack conditions from the beginning
891 - did not consider O(n) math solution counting sequences before and after
464 - could not determine the condition of when first player wins (if the second player could not win with any options)
698 - could not get from where to start - from populating cells or iterating numbers first
787 - did not consider neither dp nor Dijkstra approaches
1049 - did not consider idea of backpack and plus/minus sum
212 - did not think about reverse Trie for words instead of grid
37 - did not think about all edge cases in the solution
1130 - did not consider neither solution with min heap nor stack
18  - did not think about n^3 solution. considered it as too complex
981 - did not consider TreeMap class as a possible replacement of own implementation
    - did not think about logs as a incrementation in the timestamp, so every next record should be automatically sorted
855 - found optimal solution but could not finish it because of a lot of restrictions in conditions
85  - did not think about simplifying task to the largest rectangle in the histogram
301 - did not think about backtracking solution as not efficient. looped in the different direction
1388 - could not figure out solution, did not start thinking in DP direction and then could not implement efficient backtracking
378 - did not get idea with binary search. then was confused by returning the left pointer in the result
97  - tried to solve as a linear problem with pointers, did not consider that there is branching when chars are equal
1192 - did not get idea of Tarjan's algorithm
525 - did not think that states can be encoded by sum and that they are repeated
4   - thought about two binary searches to find a median instead of one with finding the remaining items in the second arr
1424 - did not consider the idea of summing indexes to get the diagonal
752 - did not get idea of BFS, also understood description wrong from the very beginning
315 - did not consider approach with mergesort movements
843 - did not consider idea with maximization probability of choose
472 - did not consider neither dp nor trie solution
354 - did not get idea with sorting items and searching them using a binary search
410 - did not consider idea with binary search, also did not complete dp solution by myself

Done by myself but need attention:
122 - did mistake in calculations
374 - while condition should be inclusive - while (min <= max) - in case of array with one element
100 - recursion check is more simple and efficient than migration to the array
35 - did not notice that with right shift result should be additionally incremented
922 - did not think about iterating only even indexes (i+2)
367 - overflow for integer (mid*mid). always consider overflows and edge cases.
160 - did not consider more efficient solution with two pointers
200 - did not consider option to use the same array to save space
226 - remember queue method in the linked list (pop, add and so on)
448 - after modification of the current list, we need to take abs() value to avoid negatives and index out of bounds
538 - initially did not think about simple right-order traversal
169 - check Boyer-Moore Voting Algorithm for more efficient space usage
543 - diameter for tree is sum of children depths for every node
21 - did not consider that should return first node of the result
230 - more elegant way of in-order traverse
430 - did not consider idea to reorder list with the stack
10 - did not consider that '*' quantifier can be matched 0 string. integer array for memo.
240 - did not consider better idea with search space reduction algorithm
973 - divide and conquer (partitioning) is more efficient than sorting
31  - reverse items can sort elements in descending order with O(n) instead of O(nlog(n))
56  - if crossing is found, check the max of both ends in case if one interval is inside the other.
636 - the main issue was due to the interval time calculation and messing indexes
236 - did not think about more efficient option without stack
318 - did not think about simple iteration inside the array, did not use array to store lengths
78  - did not consider option with bitwise mask
256 - modified dp before ending of the iteration and messed up remaining calculations
994 - should think better about edge cases
322 - the upper bound in 'bottom to top' approach may lead to overflow after adding a new coin
199 - edge case when the left node has deeper subtree than the right one
1007 - did not consider all test cases
856 - did not consider simpler solution with bitwise shift
545 - edge case for the binary tree, when not all leaves are not on the same level
39  - initial version of code allowed duplicates in the result
33  - need to ask if there is an option that given array is not rotated
735 - did not pay attention to the description that negative value is always going right and positive - left.
539 - did not think about bucket sort to make it in linear time complexity
692 - solved using sorting but did not think about max heap approach
1105 - needed help to define cache key in up to bottom solution, could not figure out bottom to up approach
1181 - missed test case where phrase starts and ends with the same word (match with the word itself)
1027 - done from the second attempt
54  - requires additional check
98  - the issue with MAX/MIN limits that can be in the tree nodes but should be extended in limits
1387 - use primitives in the comparator, messed up with indexes for cached numbers
518 - did not think about knapsack solution and could not get to bottom-to-up solution
909 - double check if we count intermediate transmissions or not (in other words if we need recursion there)
207 - got idea of the cycles in graphs but did not think of DFS as for the solution from the beginning
505 - BFS path search should end when all nodes are visited, not when destination is reached
127 - wrote BFS and Dijkstra with mistake on the updating child counter steps
642 - complex structure led to the errors with pointers to the objects
336 - was on the right direction with suffixes and prefixes but could not simplify it
244 - messed up solutions, O(n+m) is smaller than O(nlogm) since it is binary logarithm
55  - got the main idea but could not implement index checking, failed on test cases
1143 - got the idea of DP but stuck on the point of increasing the previous value (what is the previous result for substep)
41  - missed test case with numbers equal to the length of the array ([1])
43  - did not consider simpler solution with storing results in the integer array
1406 - did not get to dp solution from backtracking
72 - almost solved but did not figured out of using diagonal element
340 - did not consider approach with LinkedHashMap (LRU cache)

What was learned:
102 - 1) There is no Queue class, only interface. Use LinkedList for implementation
      3) Level traverse can be done with one queue and without recursion. Use queue.size() to split the current level
         from new elements.
222 - Math.pow - returns double and should be casted to int
    - name of traverses
200 - char is formatted by single quote
10  - substring() method with one argument for the string.
    - we can use 2d integer array for memo if we have pair of values
889 - there is Arrays.copyOfRange() method that can be used to make copies in recursive calls
103 - stack methods pop() and push()
94  - iterative traverse of the tree can be done with a stack
112 - object does not have default value - assign it to null manually (initialization error)
341 - list.iterator() can be used with next() and hasNext() methods
    - properties of the class are initialized to null (with no initialization error at startup)
191 - integer number consist of 32 bits
    - all bitwise operation '(n & 1) == 1' should be always put into brackets in logical condition
190 - after masking the bit, compare it with '0' and not '> 0' because of numbers with leading '1' are negative.
240 - if description says that the data is sorted the task almost always can be solved with the binary search.
347 - in-built PriorityQueue class to get the max "k" elements. Use it for interface to have poll() and add() methods.
401 - if we need only one bit in the number, we can use integer presentation {1, 2, 4, 8 ...}.
2   - to get modulo (%) from dividing by 10 we can always perform (x % 10). If it is less than 10, it will return the current value
3   - array with ASCII codes as indexes can be used to compare characters in string. Alphabet consists of 26 letters, 'A' starts at 65, 'a' at 97
973 - to initiate two-dimensional array the first dimension length should be specified (int[][] arr = new int[X][])
    - instead of creating every subarray manually, it can be done by specifying second length (int[][] arr = new int[X][Y])
    - comparator returns int but if we have float values they should be additionally casted or own logic should be placed there
    - always check the variable types!
    - heapsort is better than quicksort if we need only first K elements (NlogK complexity)
1099 - if we need to find element in the array, the worst case is to sort it and find the value with binary search. it gives nlogn.
957 - simply and brute force iterating can be also an answer but with memoization we can do it an efficient solution
    - always start with the naive solution and try to improve it
937 - Arrays.sort can be done with the range
49  - Nested structures should not be specified in variable initialization (List<List<String>> res = new ArrayList<>());
31  - To sort elements in descending order we can reverse them to make ascending order with O(n)
56  - for the task with intervals create one test case where one interval inside another
139 - when you iterate options always think for memoization. it can improve even brute force solution
    - if we have possible combinations in the description, the task probably can be solved with the dynamic programming
120 - try to reverse order in dp tasks, it might be more simpler and shorter
    - if bounds are complex, try to add if statements (even ternary version) for edge cases
636 - always check variable types and types of function results with extra attention
236 - if you need to return multiple results from the method, think about class property to store results
318 - think about simple iteration first and then do optimization step by step
389 - difference between strings can be found using bitwise ^ for all characters in both strings
767 - if not sure about converting types (for example int to char) - use casting, (char) for example
5   - for dp tasks, try to solve it with the array for memoization or matrix with results to compute and use in the next iterations
    - try to point to all facts that you know - tell what you see and try to apply it somehow for the solution
256 - optimization migth play bad thing, try to keep code as simple as possible, even if it is not so clean
71  - string builder prepending can be done with insert(0, string) but it is better to avoid it and simply do string concating
146 - in design think about what data structure provide what time complexity, try to narrow to them in the solution
994 - always think about edge cases, especially in easy task. check all of them in debugging phase
20  - mod operation is '%' (not x mod y :))
415 - the overflow from sum is named 'carry' :)
819 - simply regexp can help in the basic actions like word splitting
322 - always check for integer overflow after adding a new amount to the input parameters
    - primitive types in the array could not be sorted using a comparator
969 - if use Map.Entry always specify type in generic Map.Entry<Integer, Integer>
    - PriorityQueue by default use Arrays.sort (so it is min heap). To use as max heap a comparator is needed
    - Integer and Double should be compared usng equals, not ==
398 - random() function returns the double result and should be cast to int additionally
907 - monotone stack can be easily used to find next/previous smallest elements in the array
22  - think about simple brute force solution, do not try to improve everything from the beginning
1348 - even for hard task, try to implement the brute force solution
     - primitives can not be add to collection with objects by addAll(), should be cast one by one
545 - all lists, stacks and other objects should initialized, at least to null at the beginning
46  - size and capacity in the ArrayList are different terms (after creating an ArrayList, it should be populated manually)
609 - substring() variations with different parameters might be tricky. use the simplest and robust option
84  - recursion solution requires O(n) space if memory stack is counted
891 - to get a positive number after integer overflow, add an modulo value and then make a modulo operation
    - to do not calculate a power of 2 every time, use a pre-populated array with stored values
464 - sometimes validation of input numbers requires computation
698 - to do not create a copy of the array every time, we can update value and restore it after the recursive call
787 - if we need to check different paths/options - try a knapsack approach to store previous values on every step
    - Dijkstra algorithm can be implemented with min heap structure
539 - algorithm can be speed up to linear complexity with bucket sorting
692 - sorting strings can be done using the default compareTo() method
212 - for Trie we can store the whole word and the last node instead just a boolean flag
    - if work with string characters in arrays, do not forget to subtract 'a' char from index
1105 - for dp cache always count position and the current state of the elements
1043 - for checking a higher bound in the interval iteration, use the second condition in if instead of max/min methods
273 - edge cases can be stored in arrays instead of long switch/cases or if statements
23  - with iterative solution check if it can be improved by sorting or priority queue
18  - all 2-, 3-sum problems can be considered with hash map and two pointers solutions at the end
759 - for sweep line algorithms we need to add all pointers, sort them and iterate then.
1387 - comparator does not work with primitives, wrap int number to the Integer
substring - basic ASCII - 128 (from 0 to 127), extended - 256 (from 128 to 255)
1388 - if we can simplify task to select or skip each element - it can be solved with backtracking approach
295 - when we need to find median or work with the stream of data - we can probably use heaps
1396 - there is a Pair<Type, Type> class that can be used for tuples. Constructor and getKey()/getValue(), no setters
    - to do not use nested maps the concatenated string can be used for the key
297 - split function returns array of string elements, there is no auto casting to numbers or so
362 - when the description has some fixed range of data or time period - think about buckets
679 - to compare doubles use Double.compare() or (Math.abs(X - target) < precision)
277 - iterative solution sometimes can be an answer, or after simple optimization it can be the right answer
   - with bidirectional graphs always use visited array to avoid cycles in traversing
505 - when we need to traverse 4 directions, keep 4 arrays with shifts to the current point and apply them in the loop
525 - if you think that the problem is too simple, double check solution with cases. there may be examples
       when your approach does not work
127 - with BFS or Dijkstra search always update counter of steps for child node when you decide to enqueue it.
      if it was not decreased, it could be pulled again with another link and updated twice with different values
642  - in design problems try to make simple and clean structure even with additional properties to reduce code
678  - backtracking of continuous sequence of numbers can be replaced with two lo and hi boundaries and collected in O(n) time
269  - to remove element from map during iteration, use it = keySet().iterator(), it.hasNext() / it.next() and it.remove()
     - to define cycles a DFS can be used with marking visiting nodes separately from visited and not visited
244  - when we speak about logarithmic complexity - it is a binary logarithm (you can count number of steps dividing by two)
1143 - almost every dp matrix can be optimized in space complexity by adding a prev[] array for the last row if it is needed
     - LinkedHashSet can be used when we need to save the order of inserts
tree - with binary trees think about recursive and DFS approach first, BFS and iterative traverse usually a bit complicated
1406 - we can get from backtracking to DP if imagine how memo is populated from end to the beginning
340  - LinkedHashMap is a combination of a linked list and hashmap (LRU cache)
329  - as opposite of backtracking and dfs always think for dp and topological sort
